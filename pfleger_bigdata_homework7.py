# -*- coding: utf-8 -*-
"""pfleger-bigdata-homework7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lytsH0st9KkyAAcLVZ5aCty0z-8Kl7aa
"""

# MATTHEW PFLEGER
# CS 4265-01
# HOMEWORK 7
# DEC 1 2025

## Dataset: https://www.kaggle.com/datasets/erdemtaha/cancer-data

!pip install pennylane
!pip install scikit-learn matplotlib numpy pandas
!pip install tqdm

import pennylane as qml
from pennylane import numpy as pnp
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from tqdm import tqdm
import os

# Import dataset
data_path = "/content/sample_data/Cancer_Data.csv"
df1 = pd.read_csv(data_path)
df2 = df1[['radius_mean', 'texture_mean', 'perimeter_mean', 'area_mean', 'smoothness_mean', 'compactness_mean', 'concavity_mean', 'diagnosis']]

df2.head()

# Features
X = df2[['radius_mean', 'texture_mean', 'perimeter_mean', 'area_mean', 'smoothness_mean', 'compactness_mean', 'concavity_mean']]

## Standardize
scaler = StandardScaler()
X = scaler.fit_transform(X)

## PCA fitting and transforming
from sklearn.decomposition import PCA
pca = PCA(n_components=2)
X = pca.fit_transform(X)

## Normalize the output to range (-1,1)
minmax_scale = MinMaxScaler((-1,1))
X = minmax_scale.fit_transform(X).astype('float64')

# Target
y = df2['diagnosis'].astype('category').cat.codes.astype('float64')

# Split the dataset into training and testing data
X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.8, random_state=88)

# Classical SVM model
classifier = SVC(kernel='linear', random_state=73)
classifier.fit(X_train, y_train)

## Eval SVM model
y_pred_classical = classifier.predict(X_test)
accuracy_classical = accuracy_score(y_test, y_pred_classical)
print(f"Classical SVM Accuracy: {accuracy_classical}")

# Define quantum device
n_qubits = 2
dev = qml.device("default.qubit", wires=n_qubits)

# Define quantum circuit with feature map
def feature_map(x):
  for i in range(n_qubits):
    qml.Hadamard(wires=i)
    qml.RY(x[i], wires=i)

  # Entangling operation
  for i in range(n_qubits-1):
    qml.CNOT(wires=[i, i+1])
    qml.RY(np.pi/4, wires=i+1)
    qml.CNOT(wires=[i, i+1])

# Functions to compute quantum kernel
@qml.qnode(dev)
def quantum_kernel(x1, x2):
  feature_map(x1)
  qml.adjoint(feature_map)(x2)
  return qml.expval(qml.PauliZ(0))

def compute_kernel_matrix(rows_data, cols_data, desc="Kernel Matrix"):
  kernel_matrix = np.zeros((len(rows_data), len(cols_data)))
  for i, x1 in enumerate(rows_data):
    for j, x2 in enumerate(cols_data):
      kernel_matrix[i, j] = quantum_kernel(x1, x2)
  return kernel_matrix

print("Computing training kernel matrix...")
kernel_matrix_train = compute_kernel_matrix(X_train, X_train, desc="Training Kernel Matrix")

print("Computing testing kernel matrix...")
kernel_matrix_test = compute_kernel_matrix(X_test, X_train, desc='Testing Kernel Matrix')

# QSVM model using quantum kernel
qsvm_classifier = SVC(kernel='precomputed', random_state=73)
qsvm_classifier.fit(kernel_matrix_train, y_train)

## Predict using QSVM model
y_pred_qsvm = qsvm_classifier.predict(kernel_matrix_test)

## Eval QSVM model
accuracy_qsvm = accuracy_score(y_test, y_pred_qsvm)
print(f"Quantum QSVM accuracy {accuracy_qsvm}")

# Plotting comparisons of models accuracies
models = ['Classical SVM', 'Quantum QSVM']
accuracies = [accuracy_classical, accuracy_qsvm]
plt.bar(models, accuracies, color=['green', 'blue'])

## Add title and label axes
plt.title('Classical SVM v. Quantum SVM (Accuracy)')
plt.xlabel('Models')
plt.ylabel('Accuracy')

## Show plot
plt.show()